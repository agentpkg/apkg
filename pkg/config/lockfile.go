package config

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/pelletier/go-toml/v2"
)

const LockFileName = "apkg-lock.toml"

type LockFile struct {
	Version    int              `toml:"version" comment:"Auto-generated by apkg. Do not edit."`
	Skills     []SkillLockEntry `toml:"skills"`
	MCPServers []MCPLockEntry   `toml:"mcp_servers,omitempty"`
}

type SkillLockEntry struct {
	Name      string `toml:"name"`
	Git       string `toml:"git,omitempty"`
	Path      string `toml:"path,omitempty"`
	Ref       string `toml:"ref,omitempty"`
	Commit    string `toml:"commit,omitempty"`
	Integrity string `toml:"integrity,omitempty"`
}

type MCPLockEntry struct {
	Name      string `toml:"name"`
	Transport string `toml:"transport"`

	// Config mirror (for drift detection â€” if any of these change, re-resolve)
	Package    string   `toml:"package,omitempty"`
	Image      string   `toml:"image,omitempty"`
	Port       int      `toml:"port,omitempty"`
	URL        string   `toml:"url,omitempty"`
	Command    string   `toml:"command,omitempty"`
	Args       []string `toml:"args,omitempty"`
	EnvKeys    []string `toml:"env_keys,omitempty"`    // keys only, not values (security)
	HeaderKeys []string `toml:"header_keys,omitempty"` // keys only

	// Resolved fields (for reproducibility)
	ResolvedVersion string `toml:"resolved_version,omitempty"` // npm/uv resolved version
	InstallPath     string `toml:"install_path,omitempty"`     // relative to store root
	Digest          string `toml:"digest,omitempty"`           // container image digest
	Integrity       string `toml:"integrity,omitempty"`        // SHA256 of installed content
}

func ReadLockFile(data []byte) (*LockFile, error) {
	lf := &LockFile{}
	err := toml.Unmarshal(data, lf)

	return lf, err
}

func (lf *LockFile) Marshal() ([]byte, error) {
	return toml.Marshal(lf)
}

func LoadLockFile(path string) (*LockFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &LockFile{Version: 1}, nil
		}
		return nil, fmt.Errorf("reading %s: %w", path, err)
	}
	return ReadLockFile(data)
}

func SaveLockFile(path string, lf *LockFile) error {
	data, err := lf.Marshal()
	if err != nil {
		return fmt.Errorf("marshaling lockfile: %w", err)
	}
	return os.WriteFile(path, data, 0o644)
}

// GlobalLockFilePath returns the path to the global lockfile (~/.apkg/apkg-lock.toml),
// ensuring the directory exists.
func GlobalLockFilePath() (string, error) {
	dir, err := GlobalConfigDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(dir, LockFileName), nil
}
