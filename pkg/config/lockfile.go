package config

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/pelletier/go-toml/v2"
)

const LockFileName = "apkg-lock.toml"

type LockFile struct {
	Version int              `toml:"version" comment:"Auto-generated by apkg. Do not edit."`
	Skills  []SkillLockEntry `toml:"skills"`
}

type SkillLockEntry struct {
	Git       string `toml:"git,omitempty"`
	Path      string `toml:"path,omitempty"`
	Ref       string `toml:"ref,omitempty"`
	Commit    string `toml:"commit,omitempty"`
	Integrity string `toml:"integrity,omitempty"`
}

func ReadLockFile(data []byte) (*LockFile, error) {
	lf := &LockFile{}
	err := toml.Unmarshal(data, lf)

	return lf, err
}

func (lf *LockFile) Marshal() ([]byte, error) {
	return toml.Marshal(lf)
}

func LoadLockFile(path string) (*LockFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return &LockFile{Version: 1}, nil
		}
		return nil, fmt.Errorf("reading %s: %w", path, err)
	}
	return ReadLockFile(data)
}

func SaveLockFile(path string, lf *LockFile) error {
	data, err := lf.Marshal()
	if err != nil {
		return fmt.Errorf("marshaling lockfile: %w", err)
	}
	return os.WriteFile(path, data, 0o644)
}

// GlobalLockFilePath returns the path to the global lockfile (~/.apkg/apkg-lock.toml),
// ensuring the directory exists.
func GlobalLockFilePath() (string, error) {
	dir, err := GlobalConfigDir()
	if err != nil {
		return "", err
	}
	return filepath.Join(dir, LockFileName), nil
}
